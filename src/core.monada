module core

import ./primitives {
  typeof,
  instanceof,
  new,
  try,
  throw,
  invoke,
  ==,
  +,
  -,
  *,
  /,
  %,
  >,
  <,
  >=,
  <=,
  ~,
  |,
  &,
  ^,
  >>,
  <<,
  >>>,
  !,
  ||,
  &&,
  undefined,
  null,
  false,
  true
}

import ./data {
  fromJS,
  record,
  list,
  hashmap,
  getp,
  hasp,
  get,
  getIn,
  set,
  setIn,
  has,
  var,
  getv,
  setv,
  monad,
  isMonad,
  done,
  isDone,
  seq,
  transduce -> transduce'
}

let size { .size, .length } -> case
  when typeof size == "number" -> size
  when typeof length == "number" -> length
  else 0
end

let toJS x@{ .toJS } -> case
  when typeof toJS == "function" -> .toJS x ()
  else x
end

# TODO -- reduceFor ES Map, Set etc

let nativeReducer coll -> case
  when init && step && result -> r where
    let r -> init()
    let r coll -> result coll
    let r coll x -> step coll x
  end
  else undefined
end where
  let init =
    hasp coll "@@transducer/init" &&
    \-> invoke coll "@@transducer/init"
  let step = getp coll "@@transducer/step"
  let result = getp coll "@@transducer/result"
end

let defaultReducer -> .asMutable (list()) ()
let defaultReducer coll -> .asImmutable coll()
let defaultReducer coll x -> .push coll x

let reducerFor coll ->
  (nativeReducer coll) || defaultReducer

let transduce coll xf ->
  transduce coll xf (reducerFor coll)

let transduce coll xf r ->
  transduce' coll (xf r)

let map f ->
  \r -> r' where
    let r' -> r()
    let r' res -> r res
    let r' res x -> r res (f x)
  end

let map f coll ->
  transduce coll (map f)

let filter f ->
  \r -> r' where
    let r' -> r()
    let r' res -> r res
    let r' res x -> case
      when f x -> r res x
      else res
    end
  end

let filter f coll ->
  transduce coll (filter f)

let reduce f init ->
  \_ -> r' where
    let r' -> init
    let r' res -> res
    let r' res x -> f res x
  end

let reduce f init coll ->
  transduce coll (reduce f init)

let take n ->
  \r -> r' where
    let v = var 0
    let r' -> r()
    let r' res -> r res
    let r' res x -> runSync do
      n' = getv v;
      setv v (n' + 1);
      case
        when n' == n -> done res
        else r res x
      end;
    end
  end

let take n coll ->
  transduce coll (take n)

let indexed ->
  \r -> r' where
    let i = var 0
    let r' -> r()
    let r' res -> r res
    let r' res x -> runSync do
      i' = getv i;
      setv i (i' + 1);
      r res (x, i');
    end
  end

let indexed coll ->
  transduce coll (indexed)

let untilDone ->
  \r -> r' where
    let r' -> r()
    let r' res -> r res
    let r' res x -> case
      when isDone x -> done res
      else r res x
    end
  end

let untilDone coll ->
  transduce coll untilDone

let f $ g -> \x -> f (g x)

let isPromise { .then } ->
  typeof then == "function"

let runPoint p -> case
  when typeof p == "function" -> p()
  else p
end

let runMonad { current, next } -> case
  when isPromise value -> .then value runNext
  else runNext value
end where
  let value = run current
  let runNext value -> run (next value)
end

let run m -> case
  when isMonad m -> runMonad m
  else runPoint m
end

let runSync m -> case
  when isMonad m ->
    runSync (next value) where
      let { current, next } = m
      let value = runSync current
    end
  else runPoint m
end

export {
  typeof,
  instanceof,
  try,
  throw,
  new,
  invoke,
  ==,
  +,
  -,
  *,
  /,
  %,
  >,
  <,
  >=,
  <=,
  ~,
  |,
  &,
  ^,
  >>,
  <<,
  >>>,
  !,
  ||,
  &&,
  undefined,
  null,
  false,
  true,

  fromJS,
  toJS,
  size,
  record,
  list,
  hashmap,
  getp,
  hasp,
  get,
  getIn,
  set,
  setIn,
  has,
  var,
  getv,
  setv,
  monad,
  isMonad,
  done,
  isDone,
  seq,
  transduce,

  map,
  filter,
  reduce,
  take,

  run,
  runSync,

  $
}
