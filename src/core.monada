module core

import {
  TypeError,
  JSON
}

let size x = case
  when isImmutable x -> .size x
  else 0
end

let toJS x = case
  when isImmutable x -> .toJS x
  else x
end

let toJSON x = case
  when isImmutable x -> .toJSON x
  else .stringify JSON x
end

let reduceList () = .asMutable [] ()
let reduceList coll = .asImmutable coll ()
let reduceList coll x = .push coll x

let reduceMap () = .asMutable {} ()
let reduceMap coll = .asImmutable coll ()
let reduceMap coll [k, v] = .set coll k v

let reduceRecord coll =
  r where
    let r () = coll
    let r res = res
    let r res [k, v] = .set coll k v
  end

let defaultReducer = reduceList

let reducerFor coll = case
  when isList coll -> reduceList
  when isMap coll -> reduceMap
  when isRecord coll -> reduceRecord coll
  else defaultReducer
end

let monadToXF m = case
  when isMonad m -> node $ nextXF where
    let { node, step } = m
    let nextXF = monadToXF (step node)
  end
  else m
end

let for coll m =
  iterate coll (xf r) where
    let xf = monadToXF m
    let r = reducerFor coll
  end

let mapXF f r = r' where
  let r' () = r ()
  let r' res = r res
  let r' res x = r res (f x)
end

let map f = (r -> mapXF f r)

let filterXF f r = r' where
  let r' () = r ()
  let r' res = r res
  let r' res x = case
    when f x -> r res x
    else res
  end
end

let filter f = (r -> filterXF f r)

let reduce r = (_ -> r)

let reduce r coll =
  for coll (reduce r)

let takeXF n r = r' where
  let v = var 0
  let r' () = r ()
  let r' res = r res
  let r' res x = run do
    n' <- v,
    v (n' + 1),
    case
      when n' >= n -> done res
      else r res x
    end
  end
end

let take n = (r -> takeXF n r)

let indexed r = r' where
  let i = var 0
  let r' () = r ()
  let r' res = r res
  let r' res x = run do
    i' <- i,
    i (i' + 1),
    r res [x, i']
  end
end

let $ f g = (x -> f (g x))

let maybe f m = case
  when isMonad m -> case
    when f value -> value
    else maybe f (step value)
  end where
    let { node, step } = m
    let value = maybe f node
  end
  else m
end

let isPromise x = case
  when !x -> false
  else typeof (.then x) == "function"
end

let runPoint p = case
  when typeof p == "function" -> p ()
  else p
end

let runMonad { node, step } = case
  when isPromise value -> .then value runStep
  else runStep value
end where
  let value = run node
  let runStep value = run (step value)
end

let run m = case
  when isMonad m -> runMonad m
  else runPoint m
end

let generate spec = spec ()

let check spec value = spec value

let assert spec value = case
  when isError checked -> throw (TypeError description)
  else value
end where
  let checked@{ description } = check spec value
end

let spec spec = (x -> assert spec x)

let any () = [_]
let any x = _

# TODO
let aFunction = _

#{aFunction res = spec where
  spec () = [(() -> generate res)]
  spec x = case
    typeof x == "function" -> check res (x ())
    -> error (x + " is not a function")
  end
end

# TODO generated function must assert args
aFunction a res = spec where
  spec () = [(a' -> generate res)]
  spec x = case
    typeof x == "function" -> check res (x (generate a))
    -> error (x + " is not a function")
  end
end}

let aMap m = spec where
  let spec () = [for m (map ([k, v] -> [k, generate v]))]
  let spec x = case
    when size errors > 0 -> error errors
    else _
  end where
    let errors = for m do
      map ([k, v] -> [k, check v (get x k)]),
      filter ([k, v] -> isError v),
      map ([k, { description }] -> [k, description])
    end
  end
end

#{<||> a b = spec where
  spec () = [...generate a, ...generate b]
  spec x = case
    isError a' && isError b' -> TODO
    -> _
  where
    a' = check a x
    b' = check b x
  end
end}

export {
  typeof,
  instanceof,
  try,
  throw,
  new,
  ==,
  !=,
  +,
  -,
  *,
  /,
  %,
  >,
  <,
  >=,
  <=,
  ~,
  |,
  &,
  ^,
  >>,
  <<,
  >>>,
  !,
  ||,
  &&,
  var,

  fromJS,
  toJS,
  fromJSON,
  toJSON,
  size,
  List,
  Map,
  record,
  seq,
  monad,
  isMonad,
  done,
  isDone,
  error,
  isError,
  has,
  hasIn,
  get,
  getIn,
  update,
  updateIn,
  set,
  setIn,
  remove,
  removeIn,
  merge,
  mergeDeep,
  mergeWith,
  mergeDeepWith,
  isImmutable,
  isList,
  isMap,
  isRecord,
  for,

  check,
  generate,
  assert,
  spec,

  aFunction,
  aMap,

  map,
  filter,
  reduce,
  take,
  indexed,

  maybe,
  run,

  $
}
