module core

import ./primitives {
  typeof,
  instanceof,
  new,
  try,
  throw,
  invoke,
  ==,
  +,
  -,
  *,
  /,
  %,
  >,
  <,
  >=,
  <=,
  ~,
  |,
  &,
  ^,
  >>,
  <<,
  >>>,
  !,
  ||,
  &&
}

import ./coll {
  fromJS,
  fromJSON,
  List,
  Map,
  record,
  seq,
  Monad,
  isMonad,
  Done,
  isDone,
  hasp,
  getp,
  has,
  hasIn,
  get,
  getIn,
  update,
  updateIn,
  set,
  setIn,
  remove,
  removeIn,
  merge,
  mergeDeep,
  mergeWith,
  mergeDeepWith,
  isList,
  isMap,
  isRecord,
  for -> for',
  var,
  check,
  any,
  aMap,
  aFunction
}

size { .size, .length } = case
  typeof size == "number" -> size
  typeof length == "number" -> length
  -> 0
end

toJS x@{ .toJS } = case
  typeof toJS == "function" -> .toJS x
  -> x
end

toJSON x@{ .toJSON } = case
  typeof toJS == "function" -> .toJSON x
  -> _
end

# TODO -- reduceFor ES Map, Set etc

reduceList () = .asMutable []
reduceList coll = .asImmutable coll
reduceList coll x = .push coll x

reduceMap () = .asMutable {}
reduceMap coll = .asImmutable coll
reduceMap coll [k, v] = .set coll k v

reduceRecord coll =
  r where
    r () = coll
    r res = res
    r res [k, v] = .set coll k v
  end

defaultReducer = reduceList

reducerFor coll = case
  isList coll -> reduceList
  isMap coll -> reduceMap
  isRecord coll -> reduceRecord coll
  -> defaultReducer
end

monadToXF m = case
  isMonad m -> node $ nextXF where
    { node, next } = m
    nextXF = monadToXF (next node)
  end
  -> m
end

for coll m =
  for' coll (xf r) where
    xf = monadToXF m
    r = reducerFor coll
  end

map f =
  \r -> r' where
    r' () = r ()
    r' res = r res
    r' res x = r res (f x)
  end

map f coll =
  for coll (map f)

filter f =
  \r -> r' where
    r' () = r ()
    r' res = r res
    r' res x = case
      f x -> r res x
      -> res
    end
  end

filter f coll =
  for coll (filter f)

reduce r = \_ -> r

reduce r coll =
  for coll (reduce r)

take n =
  \r -> r' where
    v = var 0
    r' () = r ()
    r' res = r res
    r' res x = run do
      n' <- v
      v (n' + 1)
      case
        n' >= n -> Done res
        -> r res x
      end
    end
  end

take n coll =
  for coll (take n)

indexed r =
  r' where
    i = var 0
    r' () = r ()
    r' res = r res
    r' res x = run do
      i' <- i
      i (i' + 1)
      r res [x, i']
    end
  end

f $ g = \x -> f (g x)

isPromise { .then } =
  typeof then == "function"

runPoint p = case
  typeof p == "function" -> p ()
  -> p
end

runMonad { node, next } = case
  isPromise value -> .then value runNext
  -> runNext value
where
  value = run node
  runNext value = run (next value)
end

run m = case
  isMonad m -> runMonad m
  -> runPoint m
end

export {
  typeof,
  instanceof,
  try,
  throw,
  new,
  invoke,
  ==,
  +,
  -,
  *,
  /,
  %,
  >,
  <,
  >=,
  <=,
  ~,
  |,
  &,
  ^,
  >>,
  <<,
  >>>,
  !,
  ||,
  &&,

  fromJS,
  toJS,
  fromJSON,
  toJSON,
  size,
  List,
  Map,
  record,
  seq,
  Monad,
  Done,
  hasp,
  getp,
  has,
  hasIn,
  get,
  getIn,
  update,
  updateIn,
  set,
  setIn,
  remove,
  removeIn,
  merge,
  mergeDeep,
  mergeWith,
  mergeDeepWith,
  isList,
  isMap,
  isRecord,
  for,
  var,

  check,
  any,
  aMap,
  aFunction,

  map,
  filter,
  reduce,
  take,
  indexed,

  run,

  $
}
