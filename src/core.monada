module core

import Immutable {
  fromJS,
  getIn
}

let size { .size, .length } -> case
  when typeof size == "number" -> size
  when typeof length == "number" -> length
  else 0
end

let toJS x@{ .toJS } -> case
  when typeof toJS == "function" -> .toJS x ()
  else x
end

#{
# This doesn't work because for one thing Immutable's Map reducer expects [k, v] to be a native array
let reducerInitProp = "@@transducer/init"
let reducerStepProp = "@@transducer/step"
let reducerResultProp = "@@transducer/result"

let hasNativeReducer coll ->
  hasp coll reducerInitProp &&
  hasp coll reducerStepProp &&
  hasp coll reducerResultProp

let nativeReducerFor coll ->
  r where
    let init = getp coll reducerInitProp
    let step = getp coll reducerStepProp
    let result = getp coll reducerResultProp
    let r -> .call init coll
    let r res -> .call result coll res
    let r res x -> .call step coll res x
end

let defaultReducer -> .asMutable (ImList()) ()
let defaultReducer coll -> .asImmutable coll()
let defaultReducer coll x -> .push coll x

let reducerFor coll -> case
  when hasNativeReducer coll -> nativeReducerFor coll
  else defaultReducer
end
}

# TODO -- reduceFor ES Map, Set etc

let reduceImList -> .asMutable (ImList()) ()
let reduceImList coll -> .asImmutable coll()
let reduceImList coll x -> .push coll x

let reduceImMap -> .asMutable (ImMap()) ()
let reduceImMap coll -> .asImmutable coll()
let reduceImMap coll [k, v] -> .set coll k v

let reducerFor coll -> case
  when coll ? ImList -> reduceImList
  when coll ? ImMap -> reduceImMap
  else reduceImList
end

let transduce coll xf ->
  transduce coll xf (reducerFor coll)

let transduce coll xf r ->
  transduce' coll (xf r)

let map f ->
  \r -> r' where
    let r' -> r()
    let r' res -> r res
    let r' res x -> r res (f x)
  end

let map f coll ->
  transduce coll (map f)

let filter f ->
  \r -> r' where
    let r' -> r()
    let r' res -> r res
    let r' res x -> case
      when f x -> r res x
      else res
    end
  end

let filter f coll ->
  transduce coll (filter f)

let reduce f init ->
  \_ -> r' where
    let r' -> init
    let r' res -> res
    let r' res x -> f res x
  end

let reduce f init coll ->
  transduce coll (reduce f init)

#{
let take n ->
  \r -> r' where
    let r' -> r()
    let r' res -> r res
    let r' res x -> case
      when var() == n -> Done res
      else
    end
    let v = var (+) 0

let indexed ->
  \r -> r' where
    let r' -> r()
    let r' res -> r res
    let r' res x -> [, x]
    let v = var (+) 0
  end
}

let f $ g -> \x -> f (g x)

let isPromise { .then } ->
  typeof then == "function"

let runPoint p -> p()

let runMonad { value, next } -> case
  when isPromise v -> .then v runNext
  else runNext v
end where
  let v = run value
  let runNext v -> run (next v)
end

let run m -> case
  when m ? Monad -> runMonad m
  else runPoint m
end

export {
  typeof,
  ?,
  ==,
  +,
  -,
  ~,
  !,
  *,
  /,
  %,
  >,
  <,
  >=,
  <=,
  |,
  &,
  ^,
  >>,
  <<,
  >>>,
  ||,
  &&,
  undefined,
  null,
  false,
  true,
  try,
  throw,
  var,
  ImList,
  ImMap,
  ImRecord,
  Monad,
  get,
  hasp,
  getp,
  invoke,
  getIn,
  size,
  toJS,
  fromJS,
  transduce,
  Done,
  map,
  filter,
  reduce,
  $,
  run
}
