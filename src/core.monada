module core

import {
  TypeError,
  JSON,
  Math
}

let isTypeOf type x = typeof x == type

# TODO more of these
let isBoolean x = isTypeOf "boolean" x
let isKey x = isTypeOf "string" x
let isFunction x = isTypeOf "function" x

let isPromise x = case
  when !x -> false
  else isFunction (.then x)
end

let size x = case
  when isImmutable x -> .size x
  else 0
end

let toJS x = case
  when isImmutable x -> .toJS x
  else x
end

let toJSON x = case
  when isImmutable x -> .toJSON x
  else .stringify JSON x
end

let reduceList () = .asMutable [] ()
let reduceList coll = .asImmutable coll ()
let reduceList coll x = .push coll x

let reduceMap () = .asMutable {} ()
let reduceMap coll = .asImmutable coll ()
let reduceMap coll [k, v] = .set coll k v

let reduceRecord coll =
  r where
    let r () = coll
    let r res = res
    let r res [k, v] = .set coll k v
  end

let defaultReducer = reduceList

let reducerFor coll = case
  when isList coll -> reduceList
  when isMap coll -> reduceMap
  when isRecord coll -> reduceRecord coll
  else defaultReducer
end

let monadToXF m = case
  when isMonad m -> node $ nextXF where
    let { node, step } = m
    let nextXF = monadToXF (step node)
  end
  else m
end

let for coll m =
  iterateOne coll (xf r) where
    let xf = monadToXF m
    let r = reducerFor coll
  end

let for ...args =
  iterateMany colls (xf r) where
    let colls = .butLast args ()
    let m = .last args ()
    let xf = monadToXF m
    let r = defaultReducer
  end

let mapXF f r = r' where
  let r' () = r ()
  let r' res = r res
  let r' res x = r res (f x)
end

let map f = (r -> mapXF f r)

let filterXF f r = r' where
  let r' () = r ()
  let r' res = r res
  let r' res x = case
    when f x -> r res x
    else res
  end
end

let filter f = (r -> filterXF f r)

#{let findXF f r = r' where
  let r' () = r ()
  let r' res = case
    when f res -> res
    else _
  end
  let r' res x = case
    when f x -> done x
    else r res x
  end
end

let find f = (r -> findXF f r)}#

let reduceXF f init r = r' where
  let r' () = init
  let r' res = res
  let r' res x = f res x
end

let reduce f init = (r -> reduceXF f init r)

let takeWhileXF f r = r' where
  let r' () = r ()
  let r' res x = case
    when f x -> r res x
    else done res
  end
  let r' res = r res
end

let takeWhile f = (r -> takeWhileXF f r)

let takeXF n r = r' where
  let v = var 0
  let r' () = r ()
  let r' res = r res
  let r' res x = run do
    n' <- v,
    v (n' + 1),
    case
      when n' >= n -> done res
      else r res x
    end
  end
end

let take n = (r -> takeXF n r)

let indexed r = r' where
  let i = var 0
  let r' () = r ()
  let r' res = r res
  let r' res x = run do
    i' <- i,
    i (i' + 1),
    r res [x, i']
  end
end

let intoList = (_ -> reduceList)

let $ f g = (x -> f (g x))

#{let maybe f m = case
  when isMonad m -> case
    when f value -> value
    else maybe f (step value)
  end where
    let { node, step } = m
    let value = maybe f node
  end
  else m
end}#

let run m@{ node, step } = case
  when isMonad m -> case
    when isPromise value -> .then value runStep
    else runStep value
  end where
    let value = run node
    let runStep value = run (step value)
  end
  else case
    when isFunction m -> m ()
    else m
  end
end

let generate spec = spec ()

let check spec value = spec value

let assert spec value = case
  when checked -> throw (TypeError checked)
  else value
end where
  let checked = check spec value
end

let any () = [_]
let any x = _

let checkTypeOf type x typeDescription = case
  when typeof x != type -> x + " is not a " + typeDescription
  else _
end

let checkTypeOf type x =
  checkTypeOf type x type

let aBoolean () = [false, true]
let aBoolean x = checkTypeOf "boolean" x

let aNumber () = [-(.random Math ()), 0, .random Math ()]
let aNumber x = checkTypeOf "number" x

let aString () = ["", "some string"]
let aString x = checkTypeOf "string" x

let aKey () = [:someKey]
let aKey x = checkTypeOf "string" x "key"

let aValue value = spec where
  let spec () = [value]
  let spec x = case
    when x != value -> x + " is not " + value
    else _
  end
end

let aList l = spec where
  let spec () = [generate l]
  let spec x = case
    when !(isList x) -> x + " is not a list"
    when size errors -> errors
    else _
  end where
    let errors = for x do
      map (x -> check l x),
      filter (x -> x)
    end
  end
end

let cartesianProduct list@[first, ...rest] = case
  when list == [] -> []
  when rest == [] -> for first (map (first -> [first]))
  else merge ...products where
    let rest' = cartesianProduct rest
    let products = for first
      (map (first ->
        for rest' (map (rest -> [first, ...rest]))))
  end
end

let aMap m = spec where
  let spec () = for combinations (map generateCombination) where
    let keys = for m do
      map ([k, _] -> k),
      intoList
    end
    let combinations = cartesianProduct (for m do
      map ([_, v] -> generate v),
      intoList
    end)
    let generateCombination values = Map (for keys values (map (x -> x)))
  end
  let spec x = case
    when !(isMap x) -> x + " is not a map"
    when size errors -> errors
    else _
  end where
    let errors = for m do
      map ([k, v] -> [k, check v (get x k)]),
      filter ([k, v] -> v)
    end
  end
end

let aFunction args res = spec where
  let spec () = [f] where
    @checks args res
    let f ...args = generate res
  end
  let spec f = case
    when size errors != 0 -> errors
    else _
  end where
    let args' = cartesianProduct (for args (map generate))
    let errors = for args' do
      map (args -> check res (f ...args)),
      filter (x -> x)
    end
  end
end

let oneOf ...specs = spec where
  let spec () = merge ...(for specs (map generate))
  let spec x = case
    when size errors == size specs -> errors
    else _
  end where
    let errors = for specs do
      map (spec -> check spec x),
      takeWhile (x -> x)
    end
  end
end

let checks argSpecs resSpec = (f -> f' where
  let f' ...args = case
    when size args == size argSpecs -> res' where
      let args' = for argSpecs args do
        map ([argSpec, arg] -> assert argSpec arg)
      end
      let res' = assert resSpec (f ...args')
    end
    else throw (TypeError ("Arity not supported: " + size args))
  end
end)

export {
  typeof,
  instanceof,
  try,
  throw,
  new,
  ==,
  !=,
  +,
  -,
  *,
  /,
  %,
  >,
  <,
  >=,
  <=,
  ~,
  |,
  &,
  ^,
  >>,
  <<,
  >>>,
  !,
  ||,
  &&,
  var,

  fromJS,
  toJS,
  fromJSON,
  toJSON,
  size,
  List,
  Map,
  record,
  seq,
  monad,
  isMonad,
  done,
  isDone,
  has,
  hasIn,
  get,
  getIn,
  update,
  updateIn,
  set,
  setIn,
  remove,
  removeIn,
  merge,
  mergeDeep,
  mergeWith,
  mergeDeepWith,
  isImmutable,
  isList,
  isMap,
  isRecord,
  for,

  check,
  generate,
  assert,

  any,
  aBoolean,
  aNumber,
  aKey,
  aString,
  aValue,
  aList,
  aMap,
  aFunction,
  oneOf,

  checks,

  map,
  filter,
  reduce,
  take,
  indexed,

  run,

  $
}
