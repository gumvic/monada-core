module core

import ./primitives {
  typeof,
  instanceof,
  new,
  try,
  throw,
  invoke,
  ==,
  +,
  -,
  *,
  /,
  %,
  >,
  <,
  >=,
  <=,
  ~,
  |,
  &,
  ^,
  >>,
  <<,
  >>>,
  !,
  ||,
  &&
}

import ./data {
  fromJS,
  fromJSON,
  list,
  hashmap,
  record,
  seq,
  monad,
  isMonad,
  done,
  isDone,
  hasp,
  getp,
  has,
  hasIn,
  get,
  getIn,
  update,
  updateIn,
  set,
  setIn,
  remove,
  removeIn,
  merge,
  mergeDeep,
  mergeWith,
  mergeDeepWith,
  isList,
  isHashmap,
  isRecord,
  for -> for',
  var
}

let size { .size, .length } -> case
  when typeof size == "number" -> size
  when typeof length == "number" -> length
  else 0
end

let toJS x@{ .toJS } -> case
  when typeof toJS == "function" -> .toJS x
  else x
end

let toJSON x@{ .toJSON } -> case
  when typeof toJS == "function" -> .toJSON x
  else undefined
end

# TODO -- reduceFor ES Map, Set etc

let reduceList -> .asMutable []
let reduceList coll -> .asImmutable coll
let reduceList coll x -> .push coll x

let reduceHashmap -> .asMutable {}
let reduceHashmap coll -> .asImmutable coll
let reduceHashmap coll [k, v] -> .set coll k v

let reduceRecord = reduceHashmap

let defaultReducer = reduceList

let reducerFor coll -> case
  when isList coll -> reduceList
  when isHashmap coll -> reduceHashmap
  when isRecord coll -> reduceRecord
  else defaultReducer
end

let monadToXF m -> case
  when isMonad m -> current $ nextXF where
    let { current, next } = m
    let nextXF = monadToXF (next current)
  end
  else m
end

let for coll m ->
  for' coll (xf r) where
    let xf = monadToXF m
    let r = reducerFor coll
  end

let map f ->
  \r -> r' where
    let r' -> r()
    let r' res -> r res
    let r' res x -> r res (f x)
  end

let map f coll ->
  for coll (map f)

let filter f ->
  \r -> r' where
    let r' -> r()
    let r' res -> r res
    let r' res x -> case
      when f x -> r res x
      else res
    end
  end

let filter f coll ->
  for coll (filter f)

let reduce r -> \_ -> r

let reduce r coll ->
  for coll (reduce r)

let <~ var -> var
let var <~ value -> \-> var value

let take n ->
  \r -> r' where
    let v = var 0
    let r' -> r()
    let r' res -> r res
    let r' res x -> run do
      n' = <~ v
      v <~ (n' + 1)
      case
        when n' >= n -> done res
        else r res x
      end
    end
  end

let take n coll ->
  for coll (take n)

let indexed r ->
  r' where
    let i = var 0
    let r' -> r()
    let r' res -> r res
    let r' res x -> run do
      i' = <~ i
      i <~ (i' + 1)
      r res [x, i']
    end
  end

let f $ g -> \x -> f (g x)

let isPromise { .then } ->
  typeof then == "function"

let runPoint p -> case
  when typeof p == "function" -> p()
  else p
end

let runMonad { current, next } -> case
  when isDone value -> get value :value
  when isPromise value -> .then value runNext
  else runNext value
where
  let value = run current
  let runNext value -> run (next value)
end

let run m -> case
  when isMonad m -> runMonad m
  else runPoint m
end

export {
  typeof,
  instanceof,
  try,
  throw,
  new,
  invoke,
  ==,
  +,
  -,
  *,
  /,
  %,
  >,
  <,
  >=,
  <=,
  ~,
  |,
  &,
  ^,
  >>,
  <<,
  >>>,
  !,
  ||,
  &&,

  fromJS,
  toJS,
  fromJSON,
  toJSON,
  size,
  list,
  hashmap,
  record,
  seq,
  monad,
  isMonad,
  done,
  isDone,
  hasp,
  getp,
  has,
  hasIn,
  get,
  getIn,
  update,
  updateIn,
  set,
  setIn,
  remove,
  removeIn,
  merge,
  mergeDeep,
  mergeWith,
  mergeDeepWith,
  isList,
  isHashmap,
  isRecord,
  for,
  var,

  map,
  filter,
  reduce,
  take,
  indexed,

  run,

  $
}
