module core

import Immutable {
  fromJS,
  getIn
}

let f ~> g -> \x -> g(f x)
let f <~ g -> \x -> f(g x)

let size x -> case
  when !x -> 0
  when type (.size x) == "number" -> .size x
  when type (.length x) == "number" -> .length x
  else 0
end

let toJS x -> case
  when !x -> x
  when type (.toJS x) == "function" -> .toJS x ()
  else x
end

# TODO -- reduceFor ES Map, Set; also the rest of the Immutable collections

let reduceImList -> .asMutable (ImList()) ()
let reduceImList coll -> .asImmutable coll()
let reduceImList coll x -> .push coll x

let reduceImMap -> .asMutable (ImMap()) ()
let reduceImMap coll -> .asImmutable coll()
let reduceImMap coll [k, v] -> .set coll k v

let reducerFor coll -> case
  when isa coll ImList -> reduceImList
  when isa coll ImMap -> reduceImMap
  else reduceImList
end

let iterate' coll xf ->
  iterate coll r where
    let r = xf (reducerFor coll)
  end

let map f ->
  \r -> r' where
    let r' -> r()
    let r' res -> r res
    let r' res x -> r res (f x)
  end

let map f coll ->
  iterate coll (map f)

let filter f ->
  \r -> r' where
    let r' -> r()
    let r' res -> r res
    let r' res x -> case
      when f x -> r res x
      else res
    end
  end

let filter f coll ->
  iterate coll (filter f)

let isPromise x ->
  x && (type (.then x) == "function")

let runPoint p -> p()

let runMonad { value, next } -> case
  when isPromise v -> .then v runNext
  else runNext v
end where
  let v = run value
  let runNext v -> run (next v)
end

let run m -> case
  when isa m Monad -> runMonad m
  else runPoint m
end

export {
  type,
  isa,
  dontPanic,
  panic,
  undefined,
  null,
  false,
  true,
  ==,
  +,
  -,
  ~,
  !,
  *,
  /,
  %,
  >,
  <,
  >=,
  <=,
  |,
  &,
  ^,
  >>,
  <<,
  >>>,
  ||,
  &&,
  ImList,
  ImMap,
  ImRecord,
  Monad,
  get,
  getIn,
  size,
  toJS,
  fromJS,

  iterate' -> iterate,
  Done,
  map,
  filter,
  ~>,
  <~,
  run
}
