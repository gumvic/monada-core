module core

import {
  TypeError,
  JSON
}

size x = case
  isImmutable x -> .size x
  -> 0
end

toJS x = case
  isImmutable x -> .toJS x
  -> x
end

toJSON x = case
  isImmutable x -> .toJSON x
  -> .stringify JSON x
end

reduceList () = .asMutable [] ()
reduceList coll = .asImmutable coll ()
reduceList coll x = .push coll x

reduceMap () = .asMutable {} ()
reduceMap coll = .asImmutable coll ()
reduceMap coll [k, v] = .set coll k v

reduceRecord coll =
  r where
    r () = coll
    r res = res
    r res [k, v] = .set coll k v
  end

defaultReducer = reduceList

reducerFor coll = case
  isList coll -> reduceList
  isMap coll -> reduceMap
  isRecord coll -> reduceRecord coll
  -> defaultReducer
end

monadToXF m = case
  isMonad m -> node $ nextXF where
    { node, next } = m
    nextXF = monadToXF (next node)
  end
  -> m
end

for coll m =
  iterate coll (xf r) where
    xf = monadToXF m
    r = reducerFor coll
  end

map f =
  \r -> r' where
    r' () = r ()
    r' res = r res
    r' res x = r res (f x)
  end

map f coll =
  for coll (map f)

filter f =
  \r -> r' where
    r' () = r ()
    r' res = r res
    r' res x = case
      f x -> r res x
      -> res
    end
  end

filter f coll =
  for coll (filter f)

reduce r = \_ -> r

reduce r coll =
  for coll (reduce r)

take n =
  \r -> r' where
    v = var 0
    r' () = r ()
    r' res = r res
    r' res x = run do
      n' <- v
      v (n' + 1)
      case
        n' >= n -> done res
        -> r res x
      end
    end
  end

take n coll =
  for coll (take n)

indexed r =
  r' where
    i = var 0
    r' () = r ()
    r' res = r res
    r' res x = run do
      i' <- i
      i (i' + 1)
      r res [x, i']
    end
  end

$ f g = \x -> f (g x)

maybe f m = case
  isMonad m -> case
    f value -> value
    -> maybe f (next value)
  where
    { node, next } = m
    value = maybe f node
  end
  -> m
end

isPromise x = case
  !x -> false
  -> typeof (.then x) == "function"
end

runPoint p = case
  typeof p == "function" -> p ()
  -> p
end

runMonad { node, next } = case
  isPromise value -> .then value runNext
  -> runNext value
where
  value = run node
  runNext value = run (next value)
end

run m = case
  isMonad m -> runMonad m
  -> runPoint m
end

generate spec = spec ()

check spec value = spec value

assert spec value = case
  isError checked -> throw (TypeError description) where
    { description } = checked
  end
  -> value
where
  checked = check spec value
end

any () = _
any x = x

aFunction res = spec where
  spec () = \() -> generate res
  spec x = case
    typeof x == "function" -> check res (x ())
    -> error (x + " is not a function")
  end
end

aFunction a res = spec where
  spec () = \a' :: a -> generate res
  spec x = case
    typeof x == "function" -> check res (x (generate a))
    -> error (x + " is not a function")
  end
end

aMap m = spec where
  spec () = for m (map \[k, v] -> [k, generate v])
  spec x = case
    size errors > 0 -> error errors
    -> _
  where
    errors = for m do
      map (\[k, v] -> [k, check v (get x k)])
      filter (\[k, v] -> isError v)
      map (\[k, { description }] -> [k, description])
    end
  end
end

export {
  typeof,
  instanceof,
  try,
  throw,
  new,
  ==,
  +,
  -,
  *,
  /,
  %,
  >,
  <,
  >=,
  <=,
  ~,
  |,
  &,
  ^,
  >>,
  <<,
  >>>,
  !,
  ||,
  &&,
  var,

  fromJS,
  toJS,
  fromJSON,
  toJSON,
  size,
  List,
  Map,
  record,
  seq,
  monad,
  isMonad,
  done,
  isDone,
  error,
  isError,
  has,
  hasIn,
  get,
  getIn,
  update,
  updateIn,
  set,
  setIn,
  remove,
  removeIn,
  merge,
  mergeDeep,
  mergeWith,
  mergeDeepWith,
  isImmutable,
  isList,
  isMap,
  isRecord,
  for,

  check,
  generate,
  assert,

  aFunction,
  aMap,

  map,
  filter,
  reduce,
  take,
  indexed,

  maybe,
  run,

  $
}
